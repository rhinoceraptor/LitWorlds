// Generated by CoffeeScript 1.9.1
var bold, build, buildTest, clean, docco, err, exec, files, fs, green, launch, log, moduleExists, print, red, ref, reset, spawn, test, unlinkIfCoffeeFile, unlinkIfNotCoffeeFile, walk, which;

files = ['dist', 'src'];

test = ['spec', 'spec/spec_src'];

fs = require('fs');

print = require('util').print;

ref = require('child_process'), spawn = ref.spawn, exec = ref.exec;

try {
  which = require('which').sync;
} catch (_error) {
  err = _error;
  if (process.platform.match(/^win/) != null) {
    console.log('WARNING: the which module is required for windows\ntry: npm install which');
  }
  which = null;
}

bold = '\x1b[0;1m';

green = '\x1b[0;32m';

reset = '\x1b[0m';

red = '\x1b[0;31m';

task('docs', 'generate documentation', function() {
  return docco(function() {
    return log("Done", green);
  });
});

task('build', 'compile source', function() {
  return build(function() {
    return log("Done", green);
  });
});

task('watch', 'compile and watch', function() {
  return build(true, function() {
    return log("Watch Ended", green);
  });
});

task('test', 'build tests', function() {
  return buildTest(function() {
    return log("Test Built - See SpecRunner.hmtl", green);
  });
});

task('clean', 'clean generated files', function() {
  return clean(function() {
    return log("Removed all non-.coffeee files in lib/app, src, docs, spec, and spec/spec_src", green);
  });
});

walk = function(dir, done) {
  var results;
  results = [];
  return fs.readdir(dir, function(err, list) {
    var file, i, len, name, pending, results1, stat;
    if (err) {
      return done(err, []);
    }
    pending = list.length;
    if (!pending) {
      return done(null, results);
    }
    results1 = [];
    for (i = 0, len = list.length; i < len; i++) {
      name = list[i];
      file = dir + "/" + name;
      try {
        stat = fs.statSync(file);
      } catch (_error) {
        err = _error;
        stat = null;
      }
      if (stat != null ? stat.isDirectory() : void 0) {
        results1.push(walk(file, function(err, res) {
          var j, len1;
          for (j = 0, len1 = res.length; j < len1; j++) {
            name = res[j];
            results.push(name);
          }
          if (!--pending) {
            return done(null, results);
          }
        }));
      } else {
        results.push(file);
        if (!--pending) {
          results1.push(done(null, results));
        } else {
          results1.push(void 0);
        }
      }
    }
    return results1;
  });
};

log = function(message, color, explanation) {
  return console.log(color + message + reset + ' ' + (explanation || ''));
};

launch = function(cmd, options, callback) {
  var app;
  if (options == null) {
    options = [];
  }
  if (which) {
    cmd = which(cmd);
  }
  app = spawn(cmd, options, {
    stdio: "inherit"
  });
  return app.on('exit', function(status) {
    if (status === 0) {
      return callback();
    } else {
      return process.exit(status);
    }
  });
};

build = function(watch, callback) {
  var options;
  if (typeof watch === 'function') {
    callback = watch;
    watch = false;
  }
  options = ['-c', '-b', '-o'];
  options = options.concat(files);
  if (watch) {
    options.unshift('-w');
  }
  return launch('coffee', options, callback);
};

buildTest = function(watch, callback) {
  var options;
  if (typeof watch === 'function') {
    callback = watch;
    watch = false;
  }
  options = ['-c', '-b', '-o'];
  options = options.concat(test);
  if (watch) {
    options.unshift('-w');
  }
  return launch('coffee', options, callback);
};

unlinkIfCoffeeFile = function(file) {
  if (file.match(/\.coffee$/)) {
    fs.unlink(file.replace(/\.coffee$/, '.js'), function() {});
    return true;
  } else {
    return false;
  }
};

unlinkIfNotCoffeeFile = function(file) {
  if (!file.match(/\.coffee$/)) {
    fs.unlink(file, function() {});
    return true;
  } else {
    return false;
  }
};

clean = function(callback) {
  var file, i, len, ref1;
  try {
    ref1 = files.concat(test);
    for (i = 0, len = ref1.length; i < len; i++) {
      file = ref1[i];
      if (!unlinkIfCoffeeFile(file)) {
        walk(file, function(err, results) {
          var f, j, len1, results1;
          results1 = [];
          for (j = 0, len1 = results.length; j < len1; j++) {
            f = results[j];
            results1.push(unlinkIfNotCoffeeFile(f));
          }
          return results1;
        });
      }
    }
    return typeof callback === "function" ? callback() : void 0;
  } catch (_error) {
    err = _error;
  }
};

moduleExists = function(name) {
  try {
    return require(name);
  } catch (_error) {
    err = _error;
    log(name + " required: npm install " + name, red);
    return false;
  }
};

docco = function(callback) {
  return fs.readFile('Cakefile', 'utf8', function(readerr, text) {
    if (readerr) {
      throw readerr;
    }
    return fs.writeFile('src/Cakefile.coffee', text, function(writeerr) {
      if (writeerr) {
        throw writeerr;
      }
      return walk("src", function(err, files) {
        return launch("docco", files, function() {
          fs.unlink("src/Cakefile.coffee");
          return callback();
        });
      });
    });
  });
};
